<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Analizzatore Audio</title>
  <subtitle> <a href="mailto:alessandro.zilli@gmail.com">Invia email all'autore Zilli Alessandro - Udine</a></subtitle>
  <style>
    body {
      background-color: #111;
      color: #eee;
      font-family: monospace;
      margin: 0;
      padding: 0;
    }

    .split-container {
      display: flex;
      height: 100vh;
    }

    .filters-panel {
      width: 200px;
      padding: 15px;
      background-color: #1a1a1a;
      border-right: 1px solid #333;
      display: flex;
      flex-direction: column;
      gap: 15px;
      overflow-y: auto;
    }

    .filters-panel h3 {
      color: #0f0;
      margin: 0 0 10px 0;
      text-align: center;
      font-size: 14px;
      border-bottom: 1px solid #0f0;
      padding-bottom: 5px;
    }

    .filter-control {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .filter-control label {
      color: #0f0;
      font-size: 12px;
      margin-bottom: 3px;
    }

    .filter-control select {
      width: 100%;
      background-color: #222;
      border: 1px solid #0f0;
      color: #0f0;
      padding: 5px;
      font-size: 12px;
    }

    .filter-control input[type="range"] {
      width: 100%;
      margin: 5px 0;
      -webkit-appearance: none;
      height: 8px;
      background: #222;
      outline: none;
    }

    .filter-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #0f0;
      cursor: pointer;
    }

    .filter-presets {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 5px;
      margin-top: 10px;
    }

    .filter-presets button {
      padding: 3px;
      font-size: 11px;
    }

    .filter-visualizer {
      height: 100px;
      background-color: #000;
      border: 1px solid #0f0;
      margin-top: 10px;
      position: relative;
    }

    .filter-visualizer canvas {
      width: 100%;
      height: 100%;
    }

    .left-pane {
      width: calc(70% - 200px);
      padding: 10px 20px 20px;
      box-sizing: border-box;
      border-right: 1px solid #333;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .right-pane {
      width: 30%;
      padding: 10px;
      box-sizing: border-box;
      overflow-y: hidden;
      background-color: #1a1a1a;
      color: #ccc;
    }

    h1, #status {
      margin-bottom: 5px;
      text-align: center;
    }

    .controls-container {
      order: 1;
      margin-bottom: 10px;
    }

    .control-row {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .visualizers-container {
      order: 2;
      flex-grow: 1;
    }

    button, input[type="file"] {
      background-color: #222;
      border: 1px solid #0f0;
      color: #0f0;
      font-family: monospace;
      font-size: 14px;
      padding: 6px 12px;
      cursor: pointer;
    }

    button:hover, input[type="file"]:hover, select:hover {
      background-color: #333;
    }

    button:active {
      background-color: #444;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      border-color: #555;
    }

    select {
      background-color: #222;
      border: 1px solid #0f0;
      color: #0f0;
      font-family: monospace;
      font-size: 14px;
      padding: 6px 12px;
      max-width: 300px;
    }

    #mainVisualizer {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .visualRow {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 5px;
      width: 665px;
    }

    #waveformYAxis, #spectrogramYAxis {
      background-color: #111;
      border: 1px solid #555;
      width: 65px;
      height: 200px;
      user-select: none;
      font-size: 12px;
      color: #0f0;
    }

    #oscilloscope, #spectrogram {
      background-color: #000;
      border: 1px solid #555;
      width: 600px;
      height: 200px;
      display: block;
    }

    .harmonics-container {
      margin-top: 10px;
      height: calc(100% - 120px);
      overflow-y: hidden;
    }
    
    .harmonic-item {
      margin-bottom: 8px;
      padding: 5px;
      background-color: #222;
      border: 1px solid #333;
    }
    
    .harmonic-label {
      margin-bottom: 3px;
      color: #0f0;
      font-size: 12px;
    }
    
    .harmonic-canvas {
      background-color: #000;
      width: 100%;
      height: 30px;
      display: block;
    }

    .playlist-info {
      margin-top: 10px;
      font-size: 12px;
      color: #0f0;
      text-align: center;
    }

    .value-display {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: #0f0;
    }

    .filter-control input:disabled, 
    .filter-control select:disabled, 
    .preset-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      border-color: #555;
    }
  </style>
</head>
<body>
  <div class="split-container">
    <div class="filters-panel">
      <h3>Filtri Audio</h3>
      
      <div class="filter-control">
        <label for="filterType">Tipo Filtro:</label>
        <select id="filterType">
          <option value="none">Nessun filtro</option>
          <option value="lowpass">Low-pass</option>
          <option value="highpass">High-pass</option>
          <option value="bandpass">Band-pass</option>
          <option value="lowshelf">Low-shelf</option>
          <option value="highshelf">High-shelf</option>
          <option value="peaking">Peaking</option>
          <option value="notch">Notch</option>
          <option value="allpass">All-pass</option>
        </select>
      </div>
      
      <div class="filter-control">
        <label for="filterFreq">Frequenza:</label>
        <input type="range" id="filterFreq" min="20" max="20000" value="1000" step="1">
        <div class="value-display">
          <span>20Hz</span>
          <span id="freqValue">1000</span>
          <span>20kHz</span>
        </div>
      </div>
      
      <div class="filter-control">
        <label for="filterQ">Fattore Q:</label>
        <input type="range" id="filterQ" min="0.1" max="10" value="1" step="0.1">
        <div class="value-display">
          <span>0.1</span>
          <span id="qValue">1.0</span>
          <span>10.0</span>
        </div>
      </div>
      
      <div class="filter-control" id="gainControl" style="display: none;">
        <label for="filterGain">Guadagno (dB):</label>
        <input type="range" id="filterGain" min="-40" max="40" value="0" step="1">
        <div class="value-display">
          <span>-40</span>
          <span id="gainValue">0</span>
          <span>+40</span>
        </div>
      </div>
      
      <div class="filter-visualizer">
        <canvas id="filterCanvas"></canvas>
      </div>
      
      <div class="filter-presets">
        <button class="preset-btn" data-preset="bassi">Enfasi Bassi</button>
        <button class="preset-btn" data-preset="acuti">Enfasi Acuti</button>
        <button class="preset-btn" data-preset="telefono">Effetto Telefono</button>
        <button class="preset-btn" data-preset="radio">Effetto Radio</button>
        <button class="preset-btn" data-preset="muffled">Suono Ovattato</button>
        <button class="preset-btn" data-preset="reset">Reset</button>
      </div>
    </div>

    <div class="left-pane">
      <h1>Analizzatore Audio - Forma d'onda e Spettrogramma</h1>
      <div id="status">In attesa di permesso o file...</div>

      <div class="controls-container">
        <div class="control-row">
          <button id="useMicBtn">Usa Microfono</button>
          <input type="file" id="audioFile" accept="audio/*" multiple />
          <select id="playlistSelect"></select>
        </div>
        
        <div class="control-row">
          <button id="playBtn" disabled>Play</button>
          <button id="stopBtn" disabled>Stop</button>
          <button id="prevBtn" disabled>Prec</button>
          <button id="nextBtn" disabled>Succ</button>
          <button id="clearPlaylistBtn">Pulisci Playlist</button>
        </div>
        
        <div class="control-row">
          <button id="saveJpgBtn">Salva JPG Waveform</button>
          <button id="saveHarmonicsBtn">Salva JPG Fourier</button>
          <button id="recordVideoBtn">Registra Video</button>
        </div>
        
        <div id="playlistInfo" class="playlist-info"></div>
      </div>

      <div class="visualizers-container">
        <div id="mainVisualizer">
          <div class="visualRow" id="waveformRow">
            <canvas id="waveformYAxis" width="65" height="200"></canvas>
            <canvas id="oscilloscope" width="600" height="200"></canvas>
          </div>

          <div class="visualRow" id="spectrogramRow">
            <canvas id="spectrogramYAxis" width="65" height="200"></canvas>
            <canvas id="spectrogram" width="600" height="200"></canvas>
          </div>
        </div>
      </div>
    </div>

    <div class="right-pane">
      <h2>Analizzatore di formanti (Fourier)</h2>
      <div id="harmonicsContainer" class="harmonics-container">
      </div>
    </div>
  </div>

  <script>
    // Elementi DOM
    const oscilloscope = document.getElementById("oscilloscope");
    const oscCtx = oscilloscope.getContext("2d");
    const spectrogram = document.getElementById("spectrogram");
    const specCtx = spectrogram.getContext("2d");
    const waveformYAxis = document.getElementById("waveformYAxis");
    const waveformYAxisCtx = waveformYAxis.getContext("2d");
    const spectrogramYAxis = document.getElementById("spectrogramYAxis");
    const spectrogramYAxisCtx = spectrogramYAxis.getContext("2d");
    const useMicBtn = document.getElementById("useMicBtn");
    const audioFileInput = document.getElementById("audioFile");
    const status = document.getElementById("status");
    const playBtn = document.getElementById("playBtn");
    const stopBtn = document.getElementById("stopBtn");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const saveJpgBtn = document.getElementById("saveJpgBtn");
    const saveHarmonicsBtn = document.getElementById("saveHarmonicsBtn");
    const recordVideoBtn = document.getElementById("recordVideoBtn");
    const harmonicsContainer = document.getElementById("harmonicsContainer");
    const playlistSelect = document.getElementById("playlistSelect");
    const clearPlaylistBtn = document.getElementById("clearPlaylistBtn");
    const playlistInfo = document.getElementById("playlistInfo");

    // Elementi filtri
    const filterTypeSelect = document.getElementById("filterType");
    const filterFreqControl = document.getElementById("filterFreq");
    const filterQControl = document.getElementById("filterQ");
    const filterGainControl = document.getElementById("filterGain");
    const gainControl = document.getElementById("gainControl");
    const freqValue = document.getElementById("freqValue");
    const qValue = document.getElementById("qValue");
    const gainValue = document.getElementById("gainValue");
    const filterCanvas = document.getElementById("filterCanvas");
    const filterCtx = filterCanvas.getContext("2d");
    const presetButtons = document.querySelectorAll(".preset-btn");

    // Variabili audio
    let audioCtx = null;
    let analyser = null;
    let dataArrayTimeDomain = null;
    let dataArrayFreq = null;
    let animationId = null;
    let audioBuffer = null;
    let bufferSource = null;
    let isPlaying = false;
    let micStream = null;
    let recordedChunks = [];
    let mediaRecorder = null;
    let harmonicAnalyser = null;
    let filterNode = null;
    let micSource = null;
    let micAnalyser = null;
    let recordingActive = false;
    
    // Variabili playlist
    let playlist = [];
    let currentTrackIndex = -1;
    
    let minLogFreq, maxLogFreq;

    // Inizializza canvas del filtro
    filterCanvas.width = filterCanvas.offsetWidth;
    filterCanvas.height = filterCanvas.offsetHeight;

    // Classe per l'analizzatore di armoniche
    class HarmonicAnalyzer {
      constructor() {
        this.NUM_SINUSOIDS = 10;
        this.harmonics = [];
        this.t = 0;
        this.dt = 1/44100;
      }

      init(analyserNode, audioContext) {
        this.analyser = analyserNode;
        this.audioCtx = audioContext;
        
        harmonicsContainer.innerHTML = '';
        this.harmonics = [];
        
        for (let i = 0; i < this.NUM_SINUSOIDS; i++) {
          const container = document.createElement('div');
          container.className = 'harmonic-item';
          
          const label = document.createElement('div');
          label.className = 'harmonic-label';
          label.textContent = `Formante ${i+1}: -- Hz -- Amp: --`;
          
          const canvas = document.createElement('canvas');
          canvas.className = 'harmonic-canvas';
          canvas.width = 280;
          canvas.height = 30;
          
          container.appendChild(label);
          container.appendChild(canvas);
          harmonicsContainer.appendChild(container);
          
          this.harmonics.push({
            label,
            canvas,
            ctx: canvas.getContext('2d')
          });
        }
      }

      update() {
        if (!this.analyser) return;
        
        const freqData = new Uint8Array(this.analyser.frequencyBinCount);
        this.analyser.getByteFrequencyData(freqData);
        
        const peaks = this.findPeaks(freqData, this.audioCtx.sampleRate, this.analyser.fftSize, this.NUM_SINUSOIDS);
        peaks.sort((a, b) => a.freq - b.freq);

        this.harmonics.forEach(({label, canvas, ctx}, i) => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          if (i < peaks.length) {
            const {freq, amp} = peaks[i];
            label.textContent = `Formante ${i+1}: ${freq.toFixed(1)} Hz - Amp: ${amp.toFixed(2)}`;
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.beginPath();

            const centerY = canvas.height / 2;
            const scaleY = canvas.height / 3;
            const points = canvas.width;

            for(let x = 0; x < points; x++) {
              const y = centerY + scaleY * amp * Math.sin(2 * Math.PI * freq * (this.t + x/44100*50));
              if(x === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }

            ctx.stroke();
          } else {
            label.textContent = `Formante ${i+1}: -- Hz -- Amp: --`;
          }
        });

        this.t += this.dt;
      }

      findPeaks(data, sampleRate, fftSize, maxPeaks) {
        const peaks = [];
        const minDistance = 5;

        for(let i = 1; i < data.length - 1; i++) {
          if(data[i] > data[i-1] && data[i] > data[i+1]) {
            peaks.push({bin: i, value: data[i]});
          }
        }

        peaks.sort((a, b) => b.value - a.value);

        const filtered = [];
        for(const peak of peaks) {
          if(filtered.length >= maxPeaks) break;

          if(!filtered.some(p => Math.abs(p.bin - peak.bin) < minDistance)) {
            filtered.push(peak);
          }
        }

        return filtered.map(p => ({
          freq: p.bin * sampleRate / fftSize,
          amp: p.value / 255
        }));
      }
    }

    // Funzioni per i filtri
    function updateFilterLabels() {
      freqValue.textContent = filterFreqControl.value;
      qValue.textContent = filterQControl.value.toFixed(1);
      gainValue.textContent = filterGainControl.value;
    }

    function drawFilterResponse() {
      if (!filterNode || !audioCtx) return;
      
      const width = filterCanvas.width;
      const height = filterCanvas.height;
      
      filterCtx.clearRect(0, 0, width, height);
      
      // Nuova scala dB: da -40dB a +40dB (80dB totale)
      const minDb = -40;
      const maxDb = 40;
      const dbRange = maxDb - minDb;
      
      // Griglia
      filterCtx.strokeStyle = '#0f0';
      filterCtx.lineWidth = 0.5;
      filterCtx.beginPath();
      
      // Linee orizzontali (ogni 10dB)
      for (let db = minDb; db <= maxDb; db += 10) {
        const y = height * (1 - (db - minDb) / dbRange);
        filterCtx.moveTo(0, y);
        filterCtx.lineTo(width, y);
      }
      
      // Linee verticali
      for (let x = 0; x <= width; x += width / 8) {
        filterCtx.moveTo(x, 0);
        filterCtx.lineTo(x, height);
      }
      
      filterCtx.stroke();
      
      // Calcola la risposta in frequenza
      const freqData = new Float32Array(width);
      const magResponse = new Float32Array(width);
      const nyquist = audioCtx.sampleRate / 2;
      
      for (let i = 0; i < width; i++) {
        const freq = 20 * Math.pow(20000 / 20, i / width);
        freqData[i] = freq;
      }
      
      filterNode.getFrequencyResponse(freqData, magResponse, new Float32Array(width));
      
      // Disegna la curva di risposta (convertendo in dB)
      filterCtx.strokeStyle = '#0f0';
      filterCtx.lineWidth = 2;
      filterCtx.beginPath();
      
      for (let i = 0; i < width; i++) {
        const x = i;
        // Converti l'ampiezza in dB (20*log10)
        const db = 20 * Math.log10(Math.max(magResponse[i], 0.0001)); // Evita log(0)
        // Normalizza nella nuova scala
        const y = height * (1 - (db - minDb) / dbRange);
        
        if (i === 0) {
          filterCtx.moveTo(x, y);
        } else {
          filterCtx.lineTo(x, y);
        }
      }
      
      filterCtx.stroke();
      
      // Aggiungi indicatori per il fattore Q
      if (filterTypeSelect.value !== 'none' && filterTypeSelect.value !== 'allpass') {
        const freq = filterNode.frequency.value;
        const q = filterNode.Q.value;
        
        // Calcola la larghezza di banda (per filtri passabanda)
        let bw, f1, f2;
        if (filterTypeSelect.value === 'bandpass' || filterTypeSelect.value === 'notch' || filterTypeSelect.value === 'peaking') {
          bw = freq / q;
          f1 = freq - bw/2;
          f2 = freq + bw/2;
        } else {
          // Per altri filtri mostra solo la frequenza centrale
          f1 = f2 = freq;
        }
        
        // Converti frequenze in posizioni X
        const xFreq = width * (Math.log(freq) - minLogFreq) / (maxLogFreq - minLogFreq);
        const xF1 = width * (Math.log(f1) - minLogFreq) / (maxLogFreq - minLogFreq);
        const xF2 = width * (Math.log(f2) - minLogFreq) / (maxLogFreq - minLogFreq);
        
        // Disegna linea verticale per la frequenza centrale
        filterCtx.strokeStyle = '#ff0';
        filterCtx.lineWidth = 1;
        filterCtx.beginPath();
        filterCtx.moveTo(xFreq, 0);
        filterCtx.lineTo(xFreq, height);
        filterCtx.stroke();
        
        // Disegna area per la larghezza di banda (solo per alcuni tipi di filtro)
        if (filterTypeSelect.value === 'bandpass' || filterTypeSelect.value === 'notch' || filterTypeSelect.value === 'peaking') {
          filterCtx.fillStyle = 'rgba(255, 255, 0, 0.2)';
          filterCtx.beginPath();
          filterCtx.moveTo(xF1, 0);
          filterCtx.lineTo(xF1, height);
          filterCtx.lineTo(xF2, height);
          filterCtx.lineTo(xF2, 0);
          filterCtx.closePath();
          filterCtx.fill();
          
          // Etichette per le frequenze di taglio
          filterCtx.fillStyle = '#ff0';
          filterCtx.font = '10px monospace';
          filterCtx.textAlign = 'center';
          filterCtx.fillText('f1', xF1, height - 5);
          filterCtx.fillText('f2', xF2, height - 5);
        }
        
        // Etichetta per la frequenza centrale
        filterCtx.fillStyle = '#ff0';
        filterCtx.fillText('fc', xFreq, 15);
      }
      
      // Etichette degli assi
      filterCtx.fillStyle = '#0f0';
      filterCtx.font = '10px monospace';
      filterCtx.textAlign = 'center';
      
      // Frequenze sull'asse X (logaritmiche)
      const freqLabels = [20, 100, 500, 2000, 8000, 20000];
      freqLabels.forEach(freq => {
        const x = width * (Math.log(freq) / Math.log(20000));
        filterCtx.fillText(freq >= 1000 ? (freq/1000) + 'k' : freq, x, height - 2);
      });
      
      // dB sull'asse Y (modificato per la nuova scala)
      const dbLabels = ['-40dB', '-20dB', '0dB', '+20dB', '+40dB'];
      dbLabels.forEach((label, i) => {
        const db = minDb + (i * (dbRange / (dbLabels.length - 1)));
        const y = height * (1 - (db - minDb) / dbRange);
        filterCtx.fillStyle = '#0f0';
        filterCtx.font = '10px monospace';
        filterCtx.textAlign = 'left';
        filterCtx.fillText(label, 5, y + 3);
      });
      
      // Titolo del filtro
      filterCtx.textAlign = 'center';
      filterCtx.fillText(`Filtro: ${filterTypeSelect.options[filterTypeSelect.selectedIndex].text} (Q=${filterNode.Q.value.toFixed(2)})`, width/2, 12);
    }

    function applyFilterPreset(preset) {
      switch(preset) {
        case 'bassi':
          filterTypeSelect.value = 'lowshelf';
          filterFreqControl.value = 250;
          filterQControl.value = 1;
          filterGainControl.value = 10;
          break;
          
        case 'acuti':
          filterTypeSelect.value = 'highshelf';
          filterFreqControl.value = 4000;
          filterQControl.value = 1;
          filterGainControl.value = 10;
          break;
          
        case 'telefono':
          filterTypeSelect.value = 'bandpass';
          filterFreqControl.value = 1500;
          filterQControl.value = 3;
          break;
          
        case 'radio':
          filterTypeSelect.value = 'bandpass';
          filterFreqControl.value = 1000;
          filterQControl.value = 1.5;
          break;
          
        case 'muffled':
          filterTypeSelect.value = 'lowpass';
          filterFreqControl.value = 800;
          filterQControl.value = 0.5;
          break;
          
        case 'reset':
          filterTypeSelect.value = 'none';
          filterFreqControl.value = 1000;
          filterQControl.value = 1;
          filterGainControl.value = 0;
          break;
      }
      
      updateFilter();
      updateFilterLabels();
      drawFilterResponse();
    }

    function updateFilter() {
      if (!filterNode || !audioCtx) return;
      
      const type = filterTypeSelect.value;
      filterNode.type = type;
      filterNode.frequency.exponentialRampToValueAtTime(filterFreqControl.value, audioCtx.currentTime + 0.01);
      filterNode.Q.linearRampToValueAtTime(filterQControl.value, audioCtx.currentTime + 0.01);
      
      if (type === 'lowshelf' || type === 'highshelf' || type === 'peaking') {
        filterNode.gain.linearRampToValueAtTime(filterGainControl.value, audioCtx.currentTime + 0.01);
        gainControl.style.display = 'block';
      } else {
        gainControl.style.display = 'none';
      }
      
      // Ricollega le sorgenti audio se presenti
      reconnectAudioSources();
      
      // Forza il ridisegno immediato
      drawFilterResponse();
    }

    function reconnectAudioSources() {
      if (bufferSource && isPlaying) {
        bufferSource.disconnect();
        if (filterTypeSelect.value !== 'none') {
          bufferSource.connect(filterNode);
          filterNode.connect(analyser);
        } else {
          bufferSource.connect(analyser);
        }
      }
    }

    // Funzioni per la playlist
    function updatePlaylistSelect() {
      playlistSelect.innerHTML = '';
      playlist.forEach((track, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = track.name;
        if (index === currentTrackIndex) {
          option.selected = true;
        }
        playlistSelect.appendChild(option);
      });
      
      playlistInfo.textContent = `Brani: ${playlist.length} | Corrente: ${currentTrackIndex + 1}`;
      
      playBtn.disabled = playlist.length === 0 || isPlaying;
      stopBtn.disabled = playlist.length === 0 || !isPlaying;
      prevBtn.disabled = currentTrackIndex <= 0;
      nextBtn.disabled = currentTrackIndex >= playlist.length - 1;
    }

    function addToPlaylist(name, arrayBuffer) {
      playlist.push({
        name: name,
        data: arrayBuffer
      });
      
      if (currentTrackIndex === -1 && playlist.length > 0) {
        currentTrackIndex = 0;
      }
      
      updatePlaylistSelect();
      
      if (playlist.length === 1) {
        playBtn.disabled = false;
      }
    }

    function clearPlaylist() {
      playlist = [];
      currentTrackIndex = -1;
      audioBuffer = null;
      updatePlaylistSelect();
      stopPlayback();
      status.textContent = 'Playlist pulita';
    }

    async function loadTrack(index) {
      if (index < 0 || index >= playlist.length) {
        // Se non ci sono brani validi e il microfono era attivo, ritorna al microfono
        if (useMicBtn.textContent === "Disattiva Microfono") {
          resetToMicrophone();
        }
        return;
      }
      
      currentTrackIndex = index;
      updatePlaylistSelect();
      
      try {
        if (animationId) cancelAnimationFrame(animationId);
        if (micStream) {
          micStream.getTracks().forEach(track => track.stop());
          micSource = null;
          micAnalyser = null;
          useMicBtn.textContent = "Usa Microfono";
        }
        stopPlayback();
        initAudioContext();
        
        audioBuffer = await audioCtx.decodeAudioData(playlist[index].data.slice(0));
        status.textContent = 'Pronto: ' + playlist[index].name;
        drawStaticAxes();
        animate();
        
        // Riabilita i controlli dei filtri
        document.querySelectorAll('.filter-control input, .filter-control select, .preset-btn')
          .forEach(el => el.disabled = false);
      } catch (err) {
        status.textContent = 'Errore nel decodificare il file audio.';
        console.error(err);
      }
    }

    function initAudioContext() {
      if (audioCtx) {
        audioCtx.close();
      }
      
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      
      // Crea i nodi audio
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      analyser.smoothingTimeConstant = 0.8;
      dataArrayTimeDomain = new Uint8Array(analyser.fftSize);
      dataArrayFreq = new Uint8Array(analyser.frequencyBinCount);
      
      filterNode = audioCtx.createBiquadFilter();
      updateFilter();
      
      // Connetti l'analizzatore all'output
      analyser.connect(audioCtx.destination);
      
      if (!harmonicAnalyser) {
        harmonicAnalyser = new HarmonicAnalyzer();
      }
      harmonicAnalyser.init(analyser, audioCtx);
      
      const minFreq = 20;
      const maxFreq = audioCtx.sampleRate / 2;
      minLogFreq = Math.log(minFreq);
      maxLogFreq = Math.log(maxFreq);
      
      drawFilterResponse();
    }

    function drawOscilloscope() {
      analyser.getByteTimeDomainData(dataArrayTimeDomain);
      oscCtx.fillStyle = '#000';
      oscCtx.fillRect(0, 0, oscilloscope.width, oscilloscope.height);
      oscCtx.lineWidth = 2;
      oscCtx.strokeStyle = '#0f0';
      oscCtx.beginPath();
      const sliceWidth = oscilloscope.width / dataArrayTimeDomain.length;
      let x = 0;
      for (let i = 0; i < dataArrayTimeDomain.length; i++) {
        const v = dataArrayTimeDomain[i] / 128.0;
        const y = v * oscilloscope.height / 2;
        if (i === 0) oscCtx.moveTo(x, y);
        else oscCtx.lineTo(x, y);
        x += sliceWidth;
      }
      oscCtx.stroke();
    }

    function drawSpectrogram() {
        analyser.getByteFrequencyData(dataArrayFreq);
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = spectrogram.width;
        tempCanvas.height = spectrogram.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(spectrogram, 0, 0);

        specCtx.drawImage(tempCanvas, -1, 0);

        const nyquist = audioCtx.sampleRate / 2;

        for (let y = 0; y < spectrogram.height; y++) {
            const logPercent = 1 - (y / spectrogram.height);
            const freq = Math.exp(minLogFreq + logPercent * (maxLogFreq - minLogFreq));
            const freqIndex = Math.round((freq / nyquist) * dataArrayFreq.length);
            const intensity = dataArrayFreq[freqIndex] || 0;
            const norm = 1 - (intensity / 255);
            const invertedHue = 400 - (250 * norm);
            const color = `hsl(${invertedHue}, 100%, ${30 + (1 - norm) * 5}%)`;
            
            specCtx.fillStyle = color;
            specCtx.fillRect(spectrogram.width - 1, y, 1, 1);
        }
    }
    
    function drawWaveformYAxis() {
      const h = waveformYAxis.height;
      const w = waveformYAxis.width;
      waveformYAxisCtx.clearRect(0, 0, w, h);
      waveformYAxisCtx.fillStyle = "#0f0";
      waveformYAxisCtx.font = "12px monospace";
      waveformYAxisCtx.textAlign = "right";
      waveformYAxisCtx.textBaseline = "middle";

      const dbLabels = [0, 25, 50, 75];
      const maxDb = 100;

      dbLabels.forEach(db => {
        const yOffset = (db / maxDb) * (h / 2);
        
        if (db === 0) {
          waveformYAxisCtx.fillText(db + " dB", w - 5, h / 2);
        } else {
          waveformYAxisCtx.fillText(db + " dB", w - 5, (h / 2) - yOffset);
          waveformYAxisCtx.fillText(db + " dB", w - 5, (h / 2) + yOffset);
        }
      });
    }

    function drawSpectrogramYAxis() {
      const h = spectrogramYAxis.height;
      spectrogramYAxisCtx.clearRect(0, 0, spectrogramYAxis.width, h);
      spectrogramYAxisCtx.fillStyle = "#0f0";
      spectrogramYAxisCtx.font = "12px monospace";
      spectrogramYAxisCtx.textAlign = "right";
      
      const freqLabels = [20000, 10000, 5000, 2000, 1000, 500, 200, 100];
      
      freqLabels.forEach(freq => {
          if (!minLogFreq || Math.log(freq) > maxLogFreq) return;

          const logFreq = Math.log(freq);
          const percentY = (logFreq - minLogFreq) / (maxLogFreq - minLogFreq);
          const y = h * (1 - percentY);

          spectrogramYAxisCtx.textBaseline = "middle";
          let label = freq >= 1000 ? (freq / 1000) + "k" : freq;
          spectrogramYAxisCtx.fillText(label + " Hz", spectrogramYAxis.width - 5, y);
      });
    }

    function animate() {
      animationId = requestAnimationFrame(animate);
      drawOscilloscope();
      drawSpectrogram();
      if (harmonicAnalyser) {
        harmonicAnalyser.update();
      }
      
      // Aggiorna la risposta del filtro in tempo reale
      if (filterNode && filterTypeSelect.value !== 'none') {
        drawFilterResponse();
      }
    }
    
    function drawStaticAxes() {
        drawWaveformYAxis();
        drawSpectrogramYAxis();
    }

    function stopPlayback() {
      if (bufferSource) {
        try { bufferSource.stop(); } catch (e) {}
        bufferSource.disconnect();
        bufferSource = null;
      }
      isPlaying = false;
      updatePlaylistSelect();
    }

    function playAudio() {
      if (!audioBuffer || !audioCtx) return;
      
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().then(() => {
          startPlayback();
        });
      } else {
        startPlayback();
      }
    }

    function startPlayback() {
      stopPlayback();
      
      bufferSource = audioCtx.createBufferSource();
      bufferSource.buffer = audioBuffer;
      
      // Collegamento corretto con/senza filtro
      if (filterTypeSelect.value !== 'none') {
        bufferSource.connect(filterNode);
        filterNode.connect(analyser);
      } else {
        bufferSource.connect(analyser);
      }
      
      bufferSource.start(0);
      isPlaying = true;
      updatePlaylistSelect();

      bufferSource.onended = () => {
        isPlaying = false;
        updatePlaylistSelect();
      };
    }

    async function startMicrophone() {
      try {
        if (micStream) {
          micStream.getTracks().forEach(track => track.stop());
          if (micSource) micSource.disconnect();
          if (micAnalyser) micAnalyser.disconnect();
        }
        
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        initAudioContext(); // Inizializza il contesto audio
        
        // Crea un AnalyserNode separato per il microfono
        micAnalyser = audioCtx.createAnalyser();
        micAnalyser.fftSize = 2048;
        
        micSource = audioCtx.createMediaStreamSource(micStream);
        
        // Collegamento SENZA output audio (solo all'analizzatore)
        micSource.connect(micAnalyser);
        
        // Aggiorna gli analizzatori usati per la visualizzazione
        analyser = micAnalyser;
        dataArrayTimeDomain = new Uint8Array(analyser.fftSize);
        dataArrayFreq = new Uint8Array(analyser.frequencyBinCount);
        
        // Inizializza l'analizzatore di armoniche con il nuovo analizzatore
        if (harmonicAnalyser) {
          harmonicAnalyser.init(micAnalyser, audioCtx);
        }
        
        // Mostra avviso sui filtri
        status.textContent = 'Microfono attivo - I filtri non sono applicabili al microfono';
        
        // Disabilita i controlli dei filtri
        document.querySelectorAll('.filter-control input, .filter-control select, .preset-btn')
          .forEach(el => el.disabled = true);
        
        playBtn.disabled = true;
        stopBtn.disabled = false;
        drawStaticAxes();
        animate();
      } catch (err) {
        status.textContent = 'Errore microfono: ' + err.message;
        console.error(err);
      }
    }

    function resetToMicrophone() {
      if (micStream) {
        // Ricrea la connessione del microfono
        micSource = audioCtx.createMediaStreamSource(micStream);
        micAnalyser = audioCtx.createAnalyser();
        micAnalyser.fftSize = 2048;
        micSource.connect(micAnalyser);
        analyser = micAnalyser;
        
        // Reinizializza l'analizzatore di armoniche
        if (harmonicAnalyser) {
          harmonicAnalyser.init(micAnalyser, audioCtx);
        }
        
        status.textContent = 'Microfono attivo - I filtri non sono applicabili al microfono';
        drawStaticAxes();
        animate();
      }
    }

    // Event Listeners per i filtri
    filterTypeSelect.addEventListener("change", () => {
      updateFilter();
      updateFilterLabels();
      drawFilterResponse();
    });

    filterFreqControl.addEventListener("input", () => {
      if (filterNode) {
        filterNode.frequency.exponentialRampToValueAtTime(filterFreqControl.value, audioCtx.currentTime + 0.01);
      }
      updateFilterLabels();
      drawFilterResponse();
    });

    filterQControl.addEventListener("input", () => {
      if (filterNode) {
        filterNode.Q.linearRampToValueAtTime(filterQControl.value, audioCtx.currentTime + 0.01);
      }
      updateFilterLabels();
      drawFilterResponse();
    });

    filterGainControl.addEventListener("input", () => {
      if (filterNode) {
        filterNode.gain.linearRampToValueAtTime(filterGainControl.value, audioCtx.currentTime + 0.01);
      }
      updateFilterLabels();
      drawFilterResponse();
    });

    // Event Listeners per i preset
    presetButtons.forEach(button => {
      button.addEventListener("click", () => {
        applyFilterPreset(button.dataset.preset);
      });
    });

    // Event Listener per il microfono
    useMicBtn.addEventListener("click", async () => {
      if (animationId) cancelAnimationFrame(animationId);
      
      if (useMicBtn.textContent === "Usa Microfono") {
        await startMicrophone();
        useMicBtn.textContent = "Disattiva Microfono";
      } else {
        if (micStream) {
          micStream.getTracks().forEach(track => track.stop());
          if (micSource) micSource.disconnect();
          if (micAnalyser) micAnalyser.disconnect();
          micSource = null;
          micAnalyser = null;
          micStream = null;
        }
        useMicBtn.textContent = "Usa Microfono";
        status.textContent = "Microfono disattivato";
        
        // Riabilita i controlli dei filtri
        document.querySelectorAll('.filter-control input, .filter-control select, .preset-btn')
          .forEach(el => el.disabled = false);
        
        playBtn.disabled = playlist.length === 0;
        stopBtn.disabled = true;
        
        // Se c'Ã¨ un brano in playlist, ricaricalo
        if (currentTrackIndex >= 0) {
          loadTrack(currentTrackIndex);
        }
      }
    });

    // Altri Event Listeners
    audioFileInput.addEventListener("change", () => {
      if (audioFileInput.files.length > 0) {
        const files = Array.from(audioFileInput.files);
        files.forEach(file => {
          const reader = new FileReader();
          reader.onload = function(e) {
            addToPlaylist(file.name, e.target.result);
          };
          reader.readAsArrayBuffer(file);
        });
        status.textContent = `Aggiunti ${files.length} file alla playlist`;
      }
    });

    playlistSelect.addEventListener("change", () => {
      const selectedIndex = parseInt(playlistSelect.value);
      if (selectedIndex >= 0 && selectedIndex < playlist.length) {
        loadTrack(selectedIndex);
      }
    });

    playBtn.addEventListener("click", () => {
      if (playlist.length === 0) return;
      
      if (!isPlaying) {
        if (currentTrackIndex === -1 || audioBuffer === null) {
          if (currentTrackIndex === -1 && playlist.length > 0) {
            currentTrackIndex = 0;
          }
          if (currentTrackIndex !== -1) {
            loadTrack(currentTrackIndex).then(() => {
              playAudio();
            });
          }
        } else {
          playAudio();
        }
      }
    });

    stopBtn.addEventListener("click", () => {
      if (isPlaying) {
        stopPlayback();
      }
    });

    prevBtn.addEventListener("click", () => {
      if (currentTrackIndex > 0) {
        loadTrack(currentTrackIndex - 1);
      }
    });

    nextBtn.addEventListener("click", () => {
      if (currentTrackIndex < playlist.length - 1) {
        loadTrack(currentTrackIndex + 1);
      }
    });

    clearPlaylistBtn.addEventListener("click", () => {
      clearPlaylist();
    });

    saveJpgBtn.addEventListener("click", () => {
      const tempCanvas = document.createElement("canvas");
      const axisWidth = 65;
      const visualizerWidth = 600;
      
      tempCanvas.width = axisWidth + visualizerWidth;
      tempCanvas.height = oscilloscope.height + spectrogram.height;

      const ctx = tempCanvas.getContext("2d");
      ctx.fillStyle = "#111";
      ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

      ctx.drawImage(waveformYAxis, 0, 0);
      ctx.drawImage(oscilloscope, axisWidth, 0);
      ctx.drawImage(spectrogramYAxis, 0, oscilloscope.height);
      ctx.drawImage(spectrogram, axisWidth, oscilloscope.height);

      const link = document.createElement("a");
      link.download = "analizzatore_audio.jpg";
      link.href = tempCanvas.toDataURL("image/jpeg", 0.9);
      link.click();
    });
    
    saveHarmonicsBtn.addEventListener("click", () => {
      // Crea un canvas temporaneo per l'immagine
      const tempCanvas = document.createElement('canvas');
      const container = document.querySelector('.right-pane');
      
      // Imposta le dimensioni del canvas
      tempCanvas.width = container.offsetWidth;
      tempCanvas.height = container.offsetHeight;
      
      const ctx = tempCanvas.getContext('2d');
      
      // Disegna lo sfondo
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
      
      // Aggiungi il titolo
      ctx.fillStyle = '#0f0';
      ctx.font = 'bold 16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('Analizzatore di Armoniche', tempCanvas.width / 2, 25);
      
      // Disegna ogni elemento armonico
      const harmonicItems = harmonicsContainer.querySelectorAll('.harmonic-item');
      let yPos = 50;
      
      harmonicItems.forEach(item => {
        const label = item.querySelector('.harmonic-label');
        const canvas = item.querySelector('.harmonic-canvas');
        
        // Disegna il rettangolo di sfondo per l'elemento armonico
        ctx.fillStyle = '#222';
        ctx.fillRect(10, yPos - 20, tempCanvas.width - 20, 50);
        ctx.strokeStyle = '#333';
        ctx.strokeRect(10, yPos - 20, tempCanvas.width - 20, 50);
        
        // Disegna l'etichetta
        ctx.fillStyle = '#0f0';
        ctx.font = '12px monospace';
        ctx.textAlign = 'left';
        ctx.fillText(label.textContent, 15, yPos);
        
        // Disegna il canvas della forma d'onda
        ctx.drawImage(canvas, 15, yPos + 10);
        
        yPos += 60;
      });
      
      // Aggiungi la data e ora in basso
      const now = new Date();
      const timestamp = now.toLocaleString('it-IT');
      ctx.fillStyle = '#0f0';
      ctx.font = '10px monospace';
      ctx.textAlign = 'right';
      ctx.fillText(timestamp, tempCanvas.width - 10, tempCanvas.height - 10);
      
      // Crea il link per il download
      const link = document.createElement('a');
      link.download = 'analisi_armoniche_' + now.getTime() + '.jpg';
      link.href = tempCanvas.toDataURL('image/jpeg', 0.9);
      link.click();
    });
    
    recordVideoBtn.addEventListener("click", async () => {
      if (recordingActive) {
        // Ferma la registrazione
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
        }
        recordVideoBtn.textContent = "Registra Video";
        recordingActive = false;
        return;
      }
      
      // Avvia la registrazione
      try {
        recordingActive = true;
        recordVideoBtn.textContent = "Ferma registrazione";
        status.textContent = "Preparazione registrazione...";
        
        // Crea un canvas combinato per la registrazione
        const combinedCanvas = document.createElement('canvas');
        const axisWidth = 65;
        const visualizerWidth = 600;
        combinedCanvas.width = axisWidth + visualizerWidth;
        combinedCanvas.height = oscilloscope.height + spectrogram.height;
        const combinedCtx = combinedCanvas.getContext('2d');
        
        // Crea uno stream video dal canvas
        const videoStream = combinedCanvas.captureStream(30);
        
        // Crea uno stream audio dall'analizzatore
        const audioDestination = audioCtx.createMediaStreamDestination();
        analyser.connect(audioDestination);
        
        // Combina gli stream video e audio
        const combinedStream = new MediaStream([
          ...videoStream.getVideoTracks(),
          ...audioDestination.stream.getAudioTracks()
        ]);
        
        // Opzioni per il MediaRecorder
        const options = { mimeType: 'video/webm;codecs=vp9,opus' };
        
        // Crea il MediaRecorder
        recordedChunks = [];
        mediaRecorder = new MediaRecorder(combinedStream, options);
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            recordedChunks.push(event.data);
          }
        };
        
        mediaRecorder.onstop = () => {
          // Crea il blob e il download
          const blob = new Blob(recordedChunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          
          const a = document.createElement('a');
          a.style.display = 'none';
          a.href = url;
          a.download = 'registrazione_audio.webm';
          document.body.appendChild(a);
          a.click();
          
          setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }, 100);
          
          status.textContent = "Registrazione completata e salvata";
        };
        
        // Avvia la registrazione
        mediaRecorder.start(100); // Raccolta dati ogni 100ms
        
        // Funzione per disegnare sul canvas combinato
        function drawCombined() {
          if (!recordingActive) return;
          
          // Disegna lo sfondo
          combinedCtx.fillStyle = '#111';
          combinedCtx.fillRect(0, 0, combinedCanvas.width, combinedCanvas.height);
          
          // Disegna gli elementi
          combinedCtx.drawImage(waveformYAxis, 0, 0);
          combinedCtx.drawImage(oscilloscope, axisWidth, 0);
          combinedCtx.drawImage(spectrogramYAxis, 0, oscilloscope.height);
          combinedCtx.drawImage(spectrogram, axisWidth, oscilloscope.height);
          
          // Continua a disegnare
          requestAnimationFrame(drawCombined);
        }
        
        // Avvia il disegno
        drawCombined();
        status.textContent = "Registrazione in corso...";
        
      } catch (err) {
        console.error("Errore durante la registrazione:", err);
        status.textContent = "Errore durante la registrazione: " + err.message;
        recordingActive = false;
        recordVideoBtn.textContent = "Registra Video";
      }
    });

    // Inizializzazione
    updateFilterLabels();
    drawStaticAxes();
    // Ridimensiona il canvas del filtro quando la finestra cambia dimensione
    window.addEventListener('resize', () => {
      filterCanvas.width = filterCanvas.offsetWidth;
      filterCanvas.height = filterCanvas.offsetHeight;
      drawFilterResponse();
    });
  </script>
</body>
</html>
